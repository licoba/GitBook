---
description: HashMap散列算法、哈希冲突、哈希扩容、线程安全
---

# HashMap相关问题

## 【概念介绍】

### Hash算法（散列算法）

hash算法和散列算法是同一个，叫法不同。

Hash算法就是能把任意大小的文件或者字符串，通过计算，得到一个固定长度值的算法，例如MD5

一个Hash值可以对应无数多个不同的文件，一个文件的Hash值是唯一的。

### Hash冲突

Hash冲突就是，不同的对象，进行Hash计算之后的值相等，这两个Hash值就产生了哈希冲突。

### 头插法和尾插法

* 头插法就是在链表的头部插入，新元素永远在链表的前面
* 尾插法就是在链表的尾部插入，新元素永远在链表的尾部

### 扩容因子/Hash扩容

首先说一下，**装填因子**的概念：Hash表中元素个数 / Hash表数组长度 = 装填因子

* Hash扩容：当Hash表无法容忍更多的元素时，就会扩容成原来的2倍，对应函数`resize()`
* 扩容因子：一个值，例如hashmap的扩容因子默认是0.75，装填因子大于这个值时就可能会触发hash扩容



## 【常见问题】

### 哈希扩容的目的？

为了减少hash冲突，提高查询的效率

### 哈希扩容的时机？

在put一个新元素时，需要满足2个条件才会发生Hash扩容：

1. HashMap中的元素个数 &gt;= HashMap容量 \* 扩容因子
2. 新元素刚好落在一个非空的Hash桶上

也就是在已经达到了负载因子的承载极限，并且发生了Hash冲突，就会立马进行Hash扩容。

### 负载因子为什么是0.75？

默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。

* 扩容因子越大，例如0.8，虽然提高了空间利用率，但是也增大了hash冲突的概率，这样查找时就会变慢，变相增加了查找的时间成本。
* 扩容因子越小，虽然可以降低hash冲突的概率，但是空间利用率不够高，还会增加扩容rehash的次数

### Hash冲突的解决办法

* 开放定址法：将冲突的元素加上一个值，直到那个地方没有元素，有：线性探测、平方探测
* 拉链法：将冲突的元素，使用链表进行连接（有头插法和尾插法）
* 再哈希：将冲突的元素进行再哈希，直到没有冲突为止，然后插入
* 建立公共溢出区：专门建立一块区域来存储哈希冲突的元素

### 为什么扩容都是2倍乘？

概括：提升扩容的运算效率、减少Hash冲突

* HashMap计算元素位置时，使用的位运算代替取余运算，效率会高很多，源码里面就是与\(length-1\)进行与运算（x & 011111111111）这样的运算
* 容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，源码里面与length-1进行与运算，可以保证&运算都是与11111111进行&，如果里面有一个0，那么&的结果，就不是每个下标几率都相等了，会造成Hash冲突。（最主要的原因是，如果不是2的n次幂，那运算出来的结果根本就不是取余的结果了，这个hash算法的定义就相悖）

### put方法流程

首先调用hash\(key\)得到key的hash值

1. 如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；　
2. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；　
3. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。

（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）

（注意：当碰撞导致链表大于 TREEIFY\_THRESHOLD = 8 时，就把链表转换成红黑树）

### JDK 1.7 和 1.8里HashMap的区别

主要是在JDK 1.8里面加入了红黑树。

1. 在JDK 1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
2. 发生hash碰撞时，JDK 1.7 会在链表的头部插入，而JDK 1.8会在链表的尾部插入
3. 在JDK 1.8中，节点是一个Node；JDK 1.7 里面是一个Entry



### HashMap构造函数的参数含义

HashMap 有四个构造函数，分别是：

* HashMap\(\)
* HashMap\(int initialCapacity\)
* HashMap\(int initialCapacity, float loadFactor\)
* HashMap\(Map&lt;? extends K, ? extends V&gt; m\)

看一下 `HashMap(int initialCapacity, float loadFactor)` 这个构造函数里面的两个参数：

* initialCapacity：数组的初始容量大小，默认是16
* loadFactor：扩容因子，当负载因子超过这个数的时候就会发生hash扩容

  





## 【参考博客】

* [https://www.huaweicloud.com/zhishi/arc-8360144.html](https://www.huaweicloud.com/zhishi/arc-8360144.html)



