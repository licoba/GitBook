---
description: HashMap散列算法、哈希冲突、哈希扩容、线程安全
---

# HashMap和ConcurrentHashMap

首先明确几个概念

## 【概念介绍】

### Hash算法（散列算法）

hash算法和散列算法是同一个，叫法不同。

Hash算法就是能把任意大小的文件或者字符串，通过计算，得到一个固定长度值的算法，例如MD5

一个Hash值可以对应无数多个不同的文件，一个文件的Hash值是唯一的。

### Hash冲突

Hash冲突就是，不同的对象，进行Hash计算之后的值相等，这两个Hash值就产生了哈希冲突。

### 头插法和尾插法

* 头插法就是在链表的头部插入，新元素永远在链表的前面
* 尾插法就是在链表的尾部插入，新元素永远在链表的尾部

### 扩容因子/Hash扩容

首先说一下，**装填因子**的概念：Hash表中元素个数 / Hash表数组长度 = 装填因子

* Hash扩容：当Hash表无法容忍更多的元素时，就会扩容成原来的2倍
* 扩容因子：一个值，例如hashmap的扩容因子默认是0.75，装填因子大于这个值时就可能会触发hash扩容



### 

## 【常见问题】

### 哈希扩容的目的？

为了减少hash冲突，提高查询的效率

### 哈希扩容的时机？

在put一个新元素时，需要满足2个条件才会发生Hash扩容：

1. HashMap中的元素个数 &gt;= HashMap容量 \* 扩容因子
2. 新元素刚好落在一个非空的Hash桶上

也就是在已经达到了负载因子的承载极限，并且发生了Hash冲突，就会立马进行Hash扩容。

### 负载因子为什么是0.75？

默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。

* 扩容因子越大，例如0.8，虽然提高了空间利用率，但是也增大了hash冲突的概率，这样查找时就会变慢，变相增加了查找的时间成本。
* 扩容因子越小，虽然可以降低hash冲突的概率，但是空间利用率不够高，还会增加扩容rehash的次数

### Hash冲突的解决办法

* 开放定址法：将冲突的元素加上一个值，直到那个地方没有元素，有：线性探测、平方探测
* 拉链法：将冲突的元素，使用链表进行连接（有头插法和尾插法）
* 再哈希：将冲突的元素进行再哈希，直到没有冲突为止，然后插入
* 建立公共溢出区：专门建立一块区域来存储哈希冲突的元素

### 为什么扩容都是2倍乘？

概括：提升扩容的运算效率、减少Hash冲突

* HashMap计算元素位置时，使用的位运算代替取余运算，效率会高很多，源码里面就是与\(length-1\)进行与运算（x & 011111111111）这样的运算
* 容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，源码里面与length-1进行与运算，可以保证&运算都是与11111111进行&，如果里面有一个0，那么&的结果，就不是每个下标几率都相等了，会造成Hash冲突。（最主要的原因是，如果不是2的n次幂，那运算出来的结果根本就不是取余的结果了，这个hash算法的定义就相悖）



