---
description: 5个数据区域
---

# JVM内存模型

JVM也就是Java虚拟机，一般JVM内存模型，也就是指的JVM内存结构，也就是JVM运行时数据区域，这三个问题可以等价为同一个问题。

![JVM&#x8FD0;&#x884C;&#x65F6;&#x6570;&#x636E;&#x533A;&#x57DF;/&#x5185;&#x5B58;&#x7ED3;&#x6784;](../../../.gitbook/assets/image%20%283%29.png)

## JVM 数据区域（5 个）

![](https://pic.downk.cc/item/5fe3f3743ffa7d37b339ac4a.jpg)

牢牢记住这个图，只有方法区和堆是**线程共享**的，其他的都是**线程私有**的。我们先从好理解的开始说起，例如程序计数器和堆栈。

### 程序计数器

* 作用：记录当前线程执行到哪里，也就是正在执行的指令的地址

程序计数器是线程私有的，因为 JVM 是支持多线程的，是通过分配 CPU 的时间片来实现多线程的轮流切换执行的，切换到下一个线程的时候，上一个线程可能还没有执行完毕，所以每个线程都需要有一个程序计数器，来**记录当前线程执行到哪里**，在下次切换到执行这条线程的时候，可以恢复到正确的执行位置。

### 堆\(区\)

![](https://pic.downk.cc/item/5fe3fc673ffa7d37b33f7c51.jpg)

从这张图就可以看出来，堆区是存放所有对象的一块区域，因为一个对象是所有线程都可以访问的，所以堆区是**线程共享**的。除了存放对象，也可以存放数组（可以理解为数组是一种特殊的对象）。垃圾回收GC也主要是在堆区进行回收的。

### 虚拟机栈

* 栈与栈帧：每个方法从执行到执行完成，对应一个栈帧在虚拟机栈中从入栈到出栈。

虚拟机栈和线程的生命周期是绑定的，线程执行完毕了，虚拟机栈也就销毁了，所以是**线程私有**的。

**什么时候会发生StackOverFlow异常？**

答：在线程请求的虚拟机栈的深度大于JVM允许的虚拟机栈的最大深度的时候，会抛出栈溢出异常。也就是线程中的栈空间不够用了。比如：死循环的递归，就会引起栈溢出异常。如果栈的空间可以动态扩充，那么当没有足够的内存去创建一个虚拟机栈时，就会抛出内存溢出异常outofMemoryError。

#### 虚拟机栈-栈帧

一个栈帧里面包含的信息有点多：局部变量表、操作数栈、动态链接、方法返回地址、附加信息。

### 本地方法栈

虚拟机栈是管理Java方法调用的栈，那本地方法栈就是管理native方法调用的栈。本地方法栈也是**线程私有**的。如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出stackoverflowError 异常。如果栈的空间可以动态扩充，那么当没有足够的内存去创建一个本地方法栈时，就会抛出内存溢出异常outofMemoryError。

### 方法区

方法区是最后一个说到的，之前也一直不是太理解方法区是什么。其实方法区的内存结构和堆是一样的，只不过作用不一样，所以单独划分出了一块区域（方法区），方法区还有一个别名叫「Non-heap」非堆，从名字就可以看出来方法区就是为了和堆相区分的。因为和堆的结构一样，所以方法区也是**线程共享**的。

我们根据下面这张图可以看出方法区存储的数据：

![](../../../.gitbook/assets/image%20%282%29.png)

* **类型全限定名**：全限定名为 package 路径与类名称组合起来的路径；
* **类型的直接超类的全限定名**：父类或超类的全限定名；
* **类型是类类型还是接口类型**：判定当前类是 Class 还是接口 Interface；
* **类型的访问修饰符**：判断修饰符，如 pulic，private 等；
* **Class常量池**：
* **运行时常量池**
* **字段信息**：类中字段的信息；
* **方法信息**：类中方法的信息；
* **静态变量**：类中的静态变量信息；
* **一个到类 ClassLoader 的引用**：对 ClassLoader 的引用，这个引用指向对内存；
* **一个到 Class 类的引用**：对对象实例的引用，这个引用指向堆内存。

可以看到方法区虽然叫方法区，但是主要是存放和**类Class相关**的一些信息：访问修饰符、常量、static变量、类名称。

方法区内，还有一个很重要的区域：**运行时常量池**。在说运行时常量池之前有必要先说一下Class常量池。

#### Class常量池

Class常量池是每个Class文件都拥有的，在Java文件编译为Class文件的时候就已经生成了，这里的“常量”指的其实是「字面量」和「符号引用」

* 字面量：final String ss = "我爱你" 其中的“我爱你” 就是字面量
* 符号引用：类名和方法名，就是符号引用

#### 运行时常量池

JVM在加载Class时，就会将Class文件的常量池导入运行时常量池。一个运行时常量池对应着多个Class常量池。

并且运行时常量池里面的内容，并不是只来自于Class文件，也可以动态来自于代码，例如String.intern\(\)方法就可以动态向运行时常量池添加一个常量。



【参考资料】

* 书籍【深入理解 Java 虚拟机（第三版）】
* \*\*\*\*[**JVM 方法区**](https://m.imooc.com/wiki/jvm-methodarea)\*\*\*\*

