---
description: 原子性、可见性、有序性
---

# Java内存模型

### 处理器—高速缓存—内存

首先从硬件的内存模型开始说起，图中有三个成员：`处理器、高速缓存、主内存`

处理器拥有高速缓存，主内存可以理解为内存条

高速缓存是存在与处理器与内存之间的、一层为了解决处理器和内存之间的读写速度差的，缓冲区域。

处理器如果时时刻刻都从主内存去读写数据，那么将会很慢（受限与内存的读写速度）CPU的算力浪费。

所以每个处理器都有自己的高速缓存（一级、二级、三级等）运算的时候，先将数据读取到高速缓存中，直接与处理器进行交互，处理完毕之后，再写入主存，这样就可以大大提高运行速率。

![&#x5904;&#x7406;&#x5668;&#x3001;&#x9AD8;&#x901F;&#x7F13;&#x5B58;&#x3001;&#x4E3B;&#x5185;&#x5B58;&#x95F4;&#x7684;&#x4EA4;&#x4E92;&#x5173;&#x7CFB;](../../../.gitbook/assets/image%20%2818%29.png)

### Java内存模型

![&#x7EBF;&#x7A0B;&#x3001;&#x4E3B;&#x5185;&#x5B58;&#x3001;&#x5DE5;&#x4F5C;&#x5185;&#x5B58;&#x4E09;&#x8005;&#x7684;&#x4EA4;&#x4E92;&#x5173;&#x7CFB;](../../../.gitbook/assets/image%20%2817%29.png)

Java内存模型里面也有三个成员：线程、工作内存、主内存

每个线程都拥有自己的工作内存，工作内存里面保存的是主内存的副本，主内存直接与硬件内存打交道

### Volatile关键字

* Volatile关键字可以保证变量的**可见性：**在「一个线程写、多个线程同时读」的场景下可以保证线程安全，没有办法保证「多个线程同时读、多个线程同时写」的安全性。
* Volatile关键字可以 **防止指令重排序：**通过插入内存屏障，来禁止指令重排。

#### 什么是指令重排序？

> 指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。
>
> 指令重排的目的是为了在不改变**单线程下**程序执行结果的前提下，优化程序的运行效率。

#### 什么是内存屏障？

> 内存屏障是一种CPU指令，为了保证在屏障前的指令，会在屏障后的指令之前执行。

#### volatile是怎么防止指令重排序的？

> 简单理解：在变量前后，加入屏障，防止屏障前后的代码交换执行顺序。



### 原子性、可见性、有序性

* 原子性：一个或者一段操作，不能被打断，这个操作要么被完整的执行，要么执行失败
* 可见性：可见性就是指当一个线程修改了共享变量（在其它线程也能够使用的变量）的值时，其他线程能够立刻得知这个修改。
* 有序性：所有操作都是按照顺序执行的。



