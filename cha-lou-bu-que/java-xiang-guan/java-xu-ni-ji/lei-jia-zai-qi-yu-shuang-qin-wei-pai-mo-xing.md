---
description: 类加载器与双亲委派模型
---

# 类加载器与双亲委派模型

### 类加载器

类加载器：ClassLoader，可以自定义类加载器。

比较两个类是否“相等“，只有在被同一个类加载器加载的情况下，比较才有价值，因为不同的类加载器加载相同的类，结果会不相等。（相等指的是：equals方法、isInstance方法等返回的结果是否相等）

### 三种类加载器

#### 1）启动类加载器

用来加载启动类库（jar包），也就是存放在java\_home/lib目录下的，Java虚拟机能识别的类库

#### 2）扩展类加载器

用来加载扩展类库（jar包），也就是存放在java\_home/lib/ext，主要是一些对Java系统类库进行功能扩展的类库

#### 3）应用程序类加载器

负责加载用户类路径上所有的类库，这个是应用程序中默认的类加载器

### 双亲委派模型

![&#x7C7B;&#x52A0;&#x8F7D;&#x5668;&#x7684;&#x53CC;&#x4EB2;&#x59D4;&#x6D3E;&#x6A21;&#x578B;](../../../.gitbook/assets/image%20%288%29.png)

双亲委派模型 要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

#### 工作过程

过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器 都是如此，因此所有的加载请求 最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

#### 好处

* 避免类的重复加载：每个类都会走到最顶层的启动类加载器去加载，如果已经加载过这个类，那么就不会重复加载。
* 保证了Java自带的类库不被篡改：如果一个类，由不同的类加载器进行加载，没有双亲委派模型的话，这个类在不同的类加载器的环境下，虽然类名一样，但是却是不同的类。

### 破坏双亲委派模型

#### 怎么破坏双亲委派机制？

重点在ClassLoader的loadClass方法，只要继承自classLoader，然后重写loadClass方法，就可以绕过双亲委派模型。

![](../../../.gitbook/assets/image%20%285%29.png)





